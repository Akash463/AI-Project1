# -*- coding: utf-8 -*-
"""finaltouchai.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S1EKyFklCGmJgSTlxA8HyRzHJfR9md1I

# **This program predicts closing price of stocks.**

# **This is the program for prediction the closing price for heromotocorp**

**Supervised Learning,
Regression task, Batch learning**
"""

!pip install quandl

import math
import quandl
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
#using scikit
from sklearn.linear_model import LinearRegression 
from sklearn.svm import SVR  #support vector regressor 
from sklearn.model_selection  import train_test_split

dataframe=quandl.get("BSE/BOM500182", authtoken="K96houAiHzzdXMREh5EZ")

#for further usage we also have given link for asian paints stock you could also check this :

#dataframe=quandl.get("BSE/BOM500820", authtoken="K96houAiHzzdXMREh5EZ") -- this is for asian paints
print(dataframe.head())
print(dataframe.tail())

print('No of rows, No of columns are:',end="")
print(dataframe.shape)

print(dataframe.dtypes)
#these are my independent variables

#complete information of my dataset is:
dataframe.info()

dataframe.describe()

print(dataframe['Deliverable Quantity'])

#dealing with null values in %  Deli. Qty to Traded Qty and Deliverable Quantity 
#1.remove data points which contain null
aoption=dataframe.dropna(subset=["% Deli. Qty to Traded Qty"],inplace=True)
dataframe.shape

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

dataframe.hist(bins=50,figsize=(20,15))
plt.show()

#lets visualize our closing price

plt.figure(figsize=(18,9))
plt.title('Original Closing Price Data')
plt.plot(dataframe['Close'])
plt.xlabel('Date',fontsize=18)
plt.ylabel('Price',fontsize=18)
plt.show()

dataframe=dataframe[['Close']]#getting the close price,,close is our independent variable
print(dataframe.head())
print(dataframe.tail())

# give here the predicting variable for how many days u want to find
n=int(input("enter here for how many days u want to predict : "))
forcasting=n

#creating another variable(prediction which will be used for predicting) it is dependent variable , in this we shifted n units up
dataframe["Prediction"]=dataframe[["Close"]].shift(-forcasting) #write inplace of -1 where for the no of days u want to predict
print(dataframe.head())
print(dataframe.tail())

#now creating the independent dataset(X)
#convert the dataframe into numpy array
#as we want only independent variables so we are dropping prediction as it was dependent
X=np.array(dataframe.drop(['Prediction'],1))
#remove the last 'n' row i.e. forcasting value
X=X[:-forcasting]#we removed the data which is to be forecast(predicted)
print(X)#this is a list of list

#now creating the dependent variable dataset which also contains null values(i.e. nan's)
Y=np.array(dataframe['Prediction'])
#in y also i am getting all values except last values which is to be predicted
Y=Y[:-forcasting]
print(Y)#this is a list # i think here we have started training our data with previous values

#now as usual we are putting 80% data to training and 20% to testing
#reference here is sklearn documentation
x_train,x_test,y_train,y_test=train_test_split(X,Y,test_size=0.2)

#as it is a regression type of problem so 
#we are using support vector machine(regressor) to train our model 
svr_rbf= SVR(kernel='rbf',C=1e3,gamma=0.1)
svr_rbf.fit(x_train,y_train)

#testing our model
#the best possible score our model can give is 1.0
#score returns the coefficient of determination R^2 of the prediction
svm_confidence=svr_rbf.score(x_test,y_test)
print("your score is :",svm_confidence)
#if ur score is near .9 means it is a great model

"""# **It seems a great score, means we trained our model in right way**"""

#create and train the linear regression model
classifierlinearregression  = LinearRegression()
#training the model
classifierlinearregression.fit(x_train,y_train)

clr_confidence=classifierlinearregression.score(x_test,y_test)
print("your score is :",clr_confidence)

"""# **It seems from here if we in this model linear regression is working more accurately.**"""

#set x_forecast equal to the last forcasting rows of the  original data set from Close column
x_forecast=np.array(dataframe.drop(['Prediction'],1))[-forcasting:]
print(x_forecast) 
#this is the original data which contains only last values not in X

import itertools

merged = list(itertools.chain(*x_forecast))
print(merged)
#this is done for a simple list instead of list of list

## now look at the prediction (for the days which we put in forcasting variables)
#now we want to compare the last x_forecast that is our original to the predicted value by model
#printing the predicted values for the same 
#using linear regression 
lr_prediction =classifierlinearregression .predict(x_forecast)
print(lr_prediction)
print("")

#using support vector regressor
svr_prediction =svr_rbf.predict(x_forecast)
print(svr_prediction)

"""***Future scope is using Correlation we could remove outliers and could come up with better model***"""